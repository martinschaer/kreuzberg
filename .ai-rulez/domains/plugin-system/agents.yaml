agents:
  # Plugin Architecture Designer
  - name: plugin-architect
    role: Design and maintain the plugin architecture framework
    context:
      - Source: crates/kreuzberg/src/plugins/mod.rs
      - Source: crates/kreuzberg/src/plugins/extractor.rs
      - Key concepts:
          - Base Plugin trait and lifecycle
          - Type-specific plugin traits (Extractor, OcrBackend, PostProcessor, Validator)
          - Trait-based extensibility
          - Thread safety requirements (Send + Sync)
    capabilities:
      - Design plugin interfaces and abstractions
      - Ensure plugin trait coherence and usability
      - Implement lifecycle management (initialize/shutdown)
      - Validate thread-safety requirements
      - Design extension points for new plugin types
    patterns:
      - All plugins implement base Plugin trait
      - Type-specific traits provide specialized interfaces
      - Async trait support for non-blocking operations
      - Thread-safe implementation required for concurrent operation

  # Registry Implementation Specialist
  - name: registry-specialist
    role: Implement and maintain plugin registry systems
    context:
      - Key concepts:
          - Separate registries per plugin type
          - RwLock-based thread-safe access
          - MIME type indexing for fast lookup
          - Priority-based ordering
          - Registration/unregistration operations
    capabilities:
      - Design efficient registry data structures
      - Implement thread-safe operations
      - Optimize lookup performance
      - Support dynamic registration
      - Debug registry issues
    patterns:
      - Registries use Arc<RwLock<>> for thread-safe concurrent access
      - MIME type index enables O(log n) lookup
      - Priority sorting enables fallback chains
      - Unregister operations maintain index consistency

  # Document Extractor Plugin Handler
  - name: extractor-plugin-manager
    role: Manage DocumentExtractor plugin lifecycle and selection
    context:
      - Source: crates/kreuzberg/src/plugins/extractor.rs
      - Key concepts:
          - DocumentExtractor trait for custom formats
          - MIME type support declaration
          - Priority-based selection
          - Async extraction interface
      - Integration points:
          - Document extraction pipeline
          - Fallback chain execution
    capabilities:
      - Register custom extractors
      - Implement DocumentExtractor trait for new formats
      - Configure extractor priority
      - Debug extraction plugin issues
      - Implement fallback strategies
    patterns:
      - Multiple extractors can claim same MIME type
      - Highest-priority extractor selected first
      - Failed extractors trigger fallback to next in priority order
      - Config-driven behavior allows per-extractor customization

  # OCR Backend Plugin Manager
  - name: ocr-backend-manager
    role: Manage OCR backend plugin lifecycle and selection
    context:
      - Source: crates/kreuzberg-py/src/plugins.rs
      - Key concepts:
          - OcrBackend trait for alternative OCR engines
          - Language support capabilities
          - Async processing interface
          - Python plugin support via FFI
      - Integration points:
          - OCR processor pipeline
          - Capability-based backend selection
    capabilities:
      - Register OCR backend plugins (Rust or Python)
      - Implement OcrBackend trait for new engines
      - Configure backend priority
      - Manage Python backend GIL
      - Select optimal backend for language/image characteristics
    patterns:
      - Multiple backends can handle same language
      - Backend selection considers language support and capability match
      - Python backends executed via tokio::task::spawn_blocking
      - GIL management critical for performance

  # Post-Processor Plugin Coordinator
  - name: postprocessor-coordinator
    role: Manage result enhancement plugins
    context:
      - Key concepts:
          - PostProcessor trait for result enhancement
          - Plugin chaining and sequencing
          - Config-driven plugin selection
          - Async result enhancement
      - Integration points:
          - Document extraction post-processing phase
          - Sequential plugin execution
    capabilities:
      - Design and implement PostProcessor plugins
      - Configure plugin chains
      - Optimize post-processing performance
      - Debug enhancement issues
    patterns:
      - Plugins executed sequentially in priority order
      - Each plugin modifies ExtractionResult in-place
      - Config controls which plugins are applied
      - Error handling allows partial results

  # Validator Plugin Manager
  - name: validator-manager
    role: Manage content validation plugins
    context:
      - Key concepts:
          - Validator trait for quality checks
          - Validation report generation
          - Issue detection and recommendations
          - Integration with extraction pipeline
    capabilities:
      - Design validation rules and checks
      - Implement Validator plugins
      - Integrate validators into extraction workflow
      - Report and act on validation failures
    patterns:
      - Validators produce detailed reports
      - Issues tracked with severity and recommendations
      - Validation failures don't block extraction (quality control)
      - Multiple validators can run on same result

  # Python Plugin FFI Bridge
  - name: python-ffi-specialist
    role: Maintain Python-Rust FFI for plugin support
    context:
      - Source: crates/kreuzberg-py/src/plugins.rs
      - Key concepts:
          - PyO3 FFI bridge
          - GIL management patterns
          - Async Python method support
          - Exception handling and translation
          - Python object caching
    capabilities:
      - Design Python plugin protocols
      - Implement PyO3 FFI bindings
      - Manage GIL safely and efficiently
      - Debug Python integration issues
      - Optimize FFI performance
    patterns:
      - Python::attach() acquires GIL temporarily
      - py.detach() releases GIL for expensive Rust operations
      - tokio::task::spawn_blocking() bridges async Rust to sync Python
      - Clone cached Python data to safely move across thread boundaries

  # Priority Selection System Specialist
  - name: priority-selector
    role: Implement and optimize priority-based plugin selection
    context:
      - Key concepts:
          - Priority levels (0-255)
          - Priority-based arbitration
          - Fallback chain execution
          - Capability-aware selection
    capabilities:
      - Design priority systems for plugin selection
      - Implement priority sorting algorithms
      - Handle priority conflicts
      - Debug selection logic
      - Optimize selection performance
    patterns:
      - Plugins sorted by priority (highest first)
      - Fallback chains iterate through plugins until success
      - Capability matching filters available plugins
      - Priority enables custom overrides and fallbacks

  # Plugin Discovery System
  - name: plugin-discoverer
    role: Implement plugin discovery and loading
    context:
      - Key concepts:
          - Static Rust plugin registration
          - Python plugin dynamic discovery
          - Module scanning and class detection
          - Plugin validation before registration
    capabilities:
      - Implement plugin discovery mechanisms
      - Design dynamic loading strategies
      - Validate plugins before registration
      - Handle discovery errors gracefully
      - Debug discovery issues
    patterns:
      - Rust plugins registered via code
      - Python plugins discovered dynamically from modules
      - Validation ensures plugin trait implementation
      - Discovery failures prevent registration

  # GIL Management Optimizer
  - name: gil-optimizer
    role: Optimize GIL usage in Python plugin execution
    context:
      - Key concepts:
          - GIL acquisition/release patterns
          - Async Python call handling
          - Data caching to minimize GIL acquisitions
          - Performance implications
    capabilities:
      - Design GIL management strategies
      - Implement efficient GIL patterns
      - Cache frequently-accessed Python data
      - Profile and optimize GIL overhead
      - Debug GIL-related issues
    patterns:
      - Minimize GIL hold time for expensive Rust operations
      - Cache Python data in Rust to avoid re-acquisition
      - Use tokio::task::spawn_blocking for async Python calls
      - Measure and optimize GIL overhead (5-55Âµs per call)
